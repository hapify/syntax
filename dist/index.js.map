{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/errors.js",
    "src/index.js",
    "src/patterns/base.js",
    "src/patterns/conditional.js",
    "src/patterns/escape.js",
    "src/patterns/evaluate.js",
    "src/patterns/index.js",
    "src/patterns/interpolate.js",
    "src/patterns/iteration.js"
  ],
  "names": [],
  "mappings": "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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "'use strict';\n\nmodule.exports = {\n    /** @type ConstructorError */\n    ConstructorError: class extends Error {},\n    /** @type ArgumentsError */\n    ArgumentsError: class extends Error {},\n    /** @type ParsingError */\n    ParsingError: class extends Error {},\n    /** @type EvaluationError */\n    EvaluationError: class extends Error {},\n    /** @type InternalError */\n    InternalError: class extends Error {},\n};\n",
    "'use strict';\n\nconst {\n    ConstructorError,\n    ArgumentsError,\n    EvaluationError\n} = require('../src/errors');\nconst Patterns = require('./patterns');\n\n/** @type {BasePattern[]} Ordered patterns */\nconst PatternsStack = [\n    Patterns.Interpolate,\n    Patterns.Conditional,\n    Patterns.Iteration,\n    Patterns.Evaluate,\n    Patterns.Escape,\n];\n\n/** @type {HapifySyntax} Syntax parser */\nmodule.exports = class HapifySyntax {\n\n    /** Constructor */\n    constructor() {\n        throw new ConstructorError('[HapifySyntax] Cannot be instanced');\n    }\n\n    /**\n     * Parser method\n     * @param {string} template\n     * @param {{}} model\n     * @return {string}\n     */\n    static run(template, model) {\n\n        // Check how many arguments\n        if (arguments.length !== 2) {\n            throw new ArgumentsError('[HapifySyntax.run] Requires two arguments');\n        }\n        \n        // Check arguments\n        if (typeof template !== 'string') {\n            throw new ArgumentsError('[HapifySyntax.run] template must be a string');\n        }\n        if (typeof model !== 'object') {\n            throw new ArgumentsError('[HapifySyntax.run] model must be an object');\n        }\n        if (model === null) {\n            throw new ArgumentsError('[HapifySyntax.run] model cannot be null');\n        }\n        \n        // Escape quotes\n        let output = HapifySyntax._escape(template);\n        \n        // Execute all patterns\n        for (const pattern of PatternsStack) {\n            output = pattern.execute(output, model);\n        }\n        \n        return HapifySyntax._eval(output, model);\n    }\n\n    /**\n     * Escape quotes\n     * @param {string} template\n     * @private\n     */\n    static _escape(template) {\n        return template.replace(/`/g, '\\\\`');\n    }\n\n    /**\n     * Eval the generated script\n     * @param {string} template\n     * @param {{}|{}[]} root\n     * @private\n     */\n    static _eval(template, root) { // eslint-disable-line no-unused-vars\n        const final = `let out = \\`${template}\\`; module.exports = out;`;\n\n        try {\n            return eval(final);\n        }\n        catch (error) {\n            HapifySyntax._log(`[HapifySyntax._eval] An error occurred during evaluation\\n\\n${error}\\n\\n${final}`);\n            throw new EvaluationError(error.message);\n        }\n    }\n\n    /**\n     * Log something\n     * @private\n     */\n    static _log(/* arguments */) {\n        console.log(...arguments); // eslint-disable-line no-console\n    }\n\n};\n",
    "'use strict';\n\nconst { ConstructorError } = require('../errors');\n\n/** @type {BasePattern} Abstract base pattern */\nmodule.exports = class BasePattern {\n\n    /** Constructor */\n    constructor() {\n        throw new ConstructorError('[BasePattern] Cannot be instanced');\n    }\n\n    /**\n     * Parser method\n     * @param {string} template\n     * @return {string}\n     */\n    static execute(template) {\n        return template;\n    }\n\n    /**\n     * Escape string and insert js code\n     * @param {string} js\n     * @return {string}\n     * @private\n     */\n    static _dynamic(js) {\n        return `\\`; ${js} out += \\``;\n    }\n\n    /**\n     * Reverse escape quotes `\n     * @param {string} code\n     * @return {string}\n     */\n    static _unescape(code) {\n        return code.replace(/\\\\`/g, '`');\n    }\n\n};\n",
    "'use strict';\n/* eslint-disable object-curly-newline */\n/* eslint-disable object-property-newline */\n\nconst BasePattern = require('./base');\n\nconst { InternalError } = require('../errors');\n\n/** @type {RegExp} if () { pattern */\nconst IfPattern = /<<\\?(\\d)?\\s+([a-zA-Z_]+)(\\s+[a-zA-Z()!+*\\-/]+)?\\s*>>/g;\n/** @type {RegExp} else if () { pattern */\nconst ElseIfPattern = /<<\\?\\?(\\d)?\\s+([a-zA-Z_]+)(\\s+[a-zA-Z()!+*\\-/]+)?\\s*>>/g;\n/** @type {RegExp} else pattern */\nconst ElsePattern = /<<\\?\\?>>/g;\n/** @type {RegExp} } pattern */\nconst EndPattern = /<<\\?>>/g;\n/** @type {[{}]} Conditions short codes & operators */\nconst Repalcements = [\n    { search: '*', replace: ' && ', escape: true },\n    { search: '/', replace: ' && !', escape: true },\n    { search: '+', replace: ' || ', escape: true },\n    { search: '-', replace: ' || !', escape: true },\n    { search: 'pr', replace: 'i.primary' },\n    { search: 'un', replace: 'i.unique' },\n    { search: 'lb', replace: 'i.label' },\n    { search: 'nu', replace: 'i.nullable' },\n    { search: 'ml', replace: 'i.multiple' },\n    { search: 'se', replace: 'i.searchable' },\n    { search: 'so', replace: 'i.sortable' },\n    { search: 'ip', replace: 'i.isPrivate' },\n    { search: 'in', replace: 'i.internal' },\n\n    { search: 'tSe', replace: 'i.type === \\'string\\' && i.subtype === \\'email\\'' },\n    { search: 'tSp', replace: 'i.type === \\'string\\' && i.subtype === \\'password\\'' },\n    { search: 'tSt', replace: 'i.type === \\'string\\' && i.subtype === \\'text\\'' },\n    { search: 'tS', replace: 'i.type === \\'string\\'' },\n\n    { search: 'tNi', replace: 'i.type === \\'number\\' && i.subtype === \\'integer\\'' },\n    { search: 'tNf', replace: 'i.type === \\'number\\' && i.subtype === \\'float\\'' },\n    { search: 'tNt', replace: 'i.type === \\'number\\' && i.subtype === \\'latitude\\'' },\n    { search: 'tNg', replace: 'i.type === \\'number\\' && i.subtype === \\'longitude\\'' },\n    { search: 'tN', replace: 'i.type === \\'number\\'' },\n\n    { search: 'tB', replace: 'i.type === \\'boolean\\'' },\n    \n    { search: 'tDd', replace: 'i.type === \\'datetime\\' && i.subtype === \\'date\\'' },\n    { search: 'tDt', replace: 'i.type === \\'datetime\\' && i.subtype === \\'time\\'' },\n    { search: 'tD', replace: 'i.type === \\'datetime\\'' },\n    \n    { search: 'tE', replace: 'i.type === \\'entity\\'' },\n];\n/** @type {Function} Convert replacement search for regexp */\nconst ForRegExp = (r) => `${r.escape ? '\\\\' : ''}${r.search}`;\n/** @type {RegExp} Dynamic regex for replacements */\nconst Condition = new RegExp(`(${Repalcements.map(ForRegExp).join('|')})`, 'g');\n/** @type {[]} Testers caching */\nconst Testers = {};\n\n/** @type {ConditionalPattern} Conditional pattern */\nmodule.exports = class ConditionalPattern extends BasePattern {\n\n    /**\n     * Parser method\n     * @param {string} template\n     * @return {string}\n     */\n    static execute(template) {\n\n        return template\n            .replace(IfPattern, (match, _count, _variable, _condition) => {\n\n                // Get the full syntax\n                const variable = ConditionalPattern._variable(_variable);\n                const tester = ConditionalPattern._tester(_condition);\n                const condition = ConditionalPattern._condition(_count, variable, tester);\n\n                return ConditionalPattern._dynamic(`if (${condition}) {`);\n            })\n            .replace(ElseIfPattern, (match, _count, _variable, _condition) => {\n\n                // Get the full syntax\n                const variable = ConditionalPattern._variable(_variable);\n                const tester = ConditionalPattern._tester(_condition);\n                const condition = ConditionalPattern._condition(_count, variable, tester);\n\n                return ConditionalPattern._dynamic(`} else if (${condition}) {`);\n            })\n            .replace(ElsePattern, () => ConditionalPattern._dynamic('} else {'))\n            .replace(EndPattern, () => ConditionalPattern._dynamic('}'));\n    }\n\n    /**\n     * Returns the full condition to be injected in the 'if' statement\n     * @param {string} _count\n     * @param {string} variable\n     * @param {string} tester\n     * @return {string}\n     */\n    static _condition(_count, variable, tester) {\n        const threshold = typeof _count === 'undefined' ? 0 : _count - 1;\n        const arrayTest = `(${variable} instanceof Array && ${variable}.filter${tester}.length > ${threshold})`;\n        const objectTest = `(!(${variable} instanceof Array) && ${tester}(${variable}))`;\n        \n        return `${arrayTest} || ${objectTest}`;\n    }\n\n    /**\n     * Convert the condition short code to tester method\n     * @param {string} _condition\n     * @return {string}\n     */\n    static _tester(_condition) {\n        \n        // Short exit\n        if (typeof _condition === 'undefined') {\n            return '((i) => i)';\n        }\n        \n        const trimed = _condition.trim();\n        \n        if (typeof Testers[trimed] === 'undefined') {\n\n            const condition = trimed\n                .replace(Condition, (match) => {\n                    const replacement = Repalcements.find((l) => l.search === match);\n                    if (!replacement) {\n                        throw new InternalError(`[ConditionalPattern._condition] Cannot find condition replacement for ${match}`);\n                    }\n\n                    return replacement.replace;\n                })\n                .trim()\n                .replace(/^&&/g, '')\n                .replace(/^\\|\\|/g, '')\n                .trim();\n\n            Testers[trimed] = `((i) => ${condition})`;\n        }\n        \n        return Testers[trimed];\n    }\n\n    /**\n     * Convert the input variable to the real variable\n     * @param {string} _variable\n     * @return {string}\n     */\n    static _variable(_variable) {\n\n        let variable = _variable;\n        if (variable === '_') variable = 'root';\n        else if (variable === 'F') variable = 'root.fields.list';\n        else if (variable === 'D') variable = 'root.dependencies.list';\n        else if (variable === 'R') variable = 'root.referencedIn';\n        \n        return variable;\n    }\n\n};\n",
    "'use strict';\n\nconst BasePattern = require('./base');\n\n/** @type {{}} Start pattern and replacer */\nconst Start = {\n    find: /\\\\<\\\\</g,\n    replace: '<<'\n};\n/** @type {{}} end pattern and replacer */\nconst End = {\n    find: /\\\\>\\\\>/g,\n    replace: '>>'\n};\n\n/** @type {EscapePattern} Escape pattern */\nmodule.exports = class EscapePattern extends BasePattern {\n\n    /**\n     * Parser method\n     * @param {string} template\n     * @return {string}\n     */\n    static execute(template) {\n        return template\n            .replace(Start.find, Start.replace)\n            .replace(End.find, End.replace);\n    }\n\n};\n",
    "'use strict';\n\nconst BasePattern = require('./base');\n\n/** @type {RegExp} Interpolation pattern */\nconst RegEx = /<<<([\\s\\S]+?)>>>/g;\n\n/** @type {EvaluatePattern} Evaluate pattern */\nmodule.exports = class EvaluatePattern extends BasePattern {\n\n    /**\n     * Parser method\n     * @param {string} template\n     * @return {string}\n     */\n    static execute(template) {\n        return template.replace(RegEx, (match, _code) => EvaluatePattern._dynamic(EvaluatePattern._unescape(_code)));\n    }\n\n};\n",
    "'use strict';\n\nmodule.exports = {\n    Conditional: require('./conditional'),\n    Escape: require('./escape'),\n    Interpolate: require('./interpolate'),\n    Evaluate: require('./evaluate'),\n    Iteration: require('./iteration')\n};\n",
    "'use strict';\n\nconst BasePattern = require('./base');\nconst { ParsingError } = require('../errors');\n\n/** @type {RegExp} Interpolation pattern */\nconst RegEx = /<<([a-zA-Z_]+)\\s+([aA_\\-R]+)\\s*>>/g;\n\n/** @type {InterpolatePattern} Interpolate pattern */\nmodule.exports = class InterpolatePattern extends BasePattern {\n\n    /**\n     * Parser method\n     * @param {string} template\n     * @return {string}\n     */\n    static execute(template) {\n        \n        return template.replace(RegEx, (match, _variable, _property) => {\n            \n            // Get the var\n            let variable = _variable;\n            if (variable === '_') variable = 'root';\n            \n            // Get the property\n            let property = _property;\n            if (property === 'aA') property = 'lowerCamel';\n            else if (property === 'AA') property = 'upperCamel';\n            else if (property === 'a') property = 'wordsLower';\n            else if (property === 'A') property = 'wordsUpper';\n            else if (property === 'a-a') property = 'hyphen';\n            else if (property === 'a_a') property = 'underscore';\n            else if (property === 'aa') property = 'oneWord';\n            else if (property === 'R') property = 'raw';\n            else throw new ParsingError(`[InterpolatePattern.execute] Unknown name property: ${property}`);\n            \n            return `\\${${variable}.names.${property}}`;\n        });\n    }\n\n};\n",
    "'use strict';\n/* eslint-disable object-curly-newline */\n/* eslint-disable object-property-newline */\n\nconst ConditionalPattern = require('./conditional');\n\n/** @type {RegExp} for() { pattern */\nconst ForPattern = /<<@(\\d)?\\s+([a-zA-Z_]+)(\\s+[a-zA-Z()!+*\\-/]+)?\\s*([a-zA-Z_]+)\\s*>>/g;\n/** @type {RegExp} } pattern */\nconst EndPattern = /<<@>>/g;\n\n/** @type {IterationPattern} Conditional pattern */\nmodule.exports = class IterationPattern extends ConditionalPattern {\n\n    /**\n     * Parser method\n     * @param {string} template\n     * @return {string}\n     */\n    static execute(template) {\n\n        return template\n            .replace(ForPattern, (match, _count, _variable, _condition, _assignment) => {\n\n                // Get the full syntax\n                const variable = IterationPattern._variable(_variable);\n                const tester = IterationPattern._tester(_condition);\n                const filter = IterationPattern._filter(_count, variable, tester);\n\n                return IterationPattern._dynamic(`for (const ${_assignment} of ${filter}) {`);\n            })\n            .replace(EndPattern, () => IterationPattern._dynamic('}'));\n    }\n\n    /**\n     * Returns the array filter\n     * @param {string} _count\n     * @param {string} variable\n     * @param {string} tester\n     * @return {string}\n     */\n    static _filter(_count, variable, tester) {\n        const slicer = typeof _count === 'undefined' ? '' : `.slice(0, ${_count})`;\n        \n        return `${variable}.filter${tester}${slicer}`;\n    }\n\n};\n"
  ]
}